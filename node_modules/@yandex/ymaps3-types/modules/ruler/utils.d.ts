import type { LngLat } from "../../imperative";
import { RulerMeasurements, RulerType } from "./YMapRulerCommon";
/**
 * Creates a geodesic line at several points
 * @param points - Points where the geodesic line is created
 * @param type - If the type is a `ruler`, then the line is not closed. If the type is a `planimeter`, then it creates a closed line
 * @param projectionType – Map projection type
 * @returns Geodesic line coordinates
 */
export declare function createGeodesicGeometry(points: LngLat[], type: RulerType): LngLat[];
/**
 * Returns a great circle segment between two coordinates
 * @param firstCoordinates - First coordinate
 * @param secondCoordinates - Second coordinate
 * @param npoints - Number of points on the great circle segment
 * @returns Great circle segment
 */
export declare function getGreatCircleSegment(firstCoordinates: LngLat, secondCoordinates: LngLat, npoints?: number): LngLat[];
/**
 * Calculates the area of a geodesic figure in square metres.
 * @param coordinates - Geodesic geometry coordinates
 * @returns Area in square metres
 */
export declare function calcArea(coordinates: LngLat[]): number;
type DistanceMeasurements = Omit<RulerMeasurements, "type" | "totalDistance">;
/**
 * Calculates measurements for each point of the line
 * @param points - Coordinates of the points on the line
 * @param projectionType – Map projection type
 * @returns Array of measurements for each point of the line
 */
export declare function calcDistance(points: LngLat[]): DistanceMeasurements[];
/**
 * Fixes the line display when crossing the border of the "world".
 * To do this, it transfers values outside the range (-180, 180) to another "world".
 * @param lineStringCoordinates - Coordinates of the points on the line
 * @returns Array of fixed coordinates
 */
export declare function unfoldLineStringByShorterDistances(lineStringCoordinates: LngLat[]): LngLat[];
export declare function getNearestPointOnLine(lineCoordinates: LngLat[], point: LngLat): {
    index: number;
    coordinates: LngLat;
};
/**
 * Finds the index of the segment at points, by the index of the segment in the geometry
 * @param geometry - Geometry coordinates
 * @param points - Points that lie on the geometry
 * @param geometrySegmentIndex - Index of segment in geometry
 * @returns The segment index found in points
 */
export declare function findIndexInGeometry(geometry: LngLat[], points: LngLat[], geometrySegmentIndex: number): number;
export declare function areLngLatFuzzyEqual(a: LngLat, b: LngLat, tolerance?: number): boolean;
export declare function areLngLatEqual(a: LngLat, b: LngLat): boolean;
export {};
