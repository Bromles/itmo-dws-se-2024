import type { WorldCoordinates } from "./coordinates";
import type { GenericGeometry } from "./geojson";
import type { PixelCoordinates } from "./coordinates";
import type { HotspotFeature } from "./hotspot";
type VectorCustomizationStyler = {
    zoom?: number | [
        number,
        number
    ];
    visibility?: 'off';
    hue?: string;
    saturation?: number;
    lightness?: number;
    color?: string;
    'secondary-color'?: string;
    'tertiary-color'?: string;
    opacity?: number;
    scale?: number;
};
type VectorCustomizationTypes = 'point' | 'polyline' | 'polygon';
type VectorCustomizationElements = 'geometry' | 'geometry.fill' | 'geometry.fill.pattern' | 'geometry.outline' | 'label' | 'label.icon' | 'label.text' | 'label.text.fill' | 'label.text.outline';
type VectorCustomizationItem = {
    tags?: {
        all?: string | string[];
        any?: string | string[];
        none?: string | string[];
    } | string;
    types?: VectorCustomizationTypes | VectorCustomizationTypes[];
    elements?: VectorCustomizationElements | VectorCustomizationElements[];
    stylers?: VectorCustomizationStyler | VectorCustomizationStyler[];
};
type VectorCustomization = VectorCustomizationItem[];
interface WorldHotspot {
    readonly type: 'world';
    readonly feature: HotspotFeature<unknown>;
    readonly geometry: GenericGeometry<WorldCoordinates>;
}
interface RenderedHotspot {
    readonly type: 'rendered';
    readonly feature: HotspotFeature<unknown>;
    readonly geometry: GenericGeometry<PixelCoordinates>;
}
type Hotspot = WorldHotspot | RenderedHotspot;
interface FetchedCommonTile {
    destroy?(): void;
}
interface FetchedRasterTile extends FetchedCommonTile {
    image: HTMLImageElement | HTMLCanvasElement | ImageBitmap;
}
/**
 * @deprecated Use FetchedRasterTile instead
 */
type FetchedTile = FetchedRasterTile;
type FetchTileFunction = (x: number, y: number, z: number, scale: number, signal: AbortSignal) => Promise<FetchedCommonTile | FetchedRasterTile>;
type ComposeTileUrlFunction = (x: number, y: number, z: number, scale: number, signal: AbortSignal) => string;
/**
 * Provides hotspots for given tile coordinates and zoom.
 * @param x Tile X
 * @param y Tile Y
 * @param z Tile Z
 * @param signal is used to abort request in case if hotspots for given tile are no longer required
 */
type FetchHotspotsFunction = (x: number, y: number, z: number, signal: AbortSignal) => Promise<Hotspot[]>;
interface RasterTileDataSourceDescription {
    /**
         * Either template tile url:
         *   - {{x}} {{y}} {{z}} placeholders for tile coordinates
         *   - {{scale}} placeholders for pixel scale (e.g. retina is 2)
         * Or function that returns final url.
         * Or function that fetches tile manually.
         */
    fetchTile: string | ComposeTileUrlFunction | FetchTileFunction;
    /** Name of data provided by this data source. Should be referenced in layer. */
    type: string;
    /** Tile size in pixels. Default is 256. */
    size?: number;
    transparent?: boolean;
    /**
         * Returns promise that is going to be resolved by hotspots for tile, or rejected with {name: 'AbortError'}.
         * Hotspots are expected to be sorted from bottom to top (aka far to near).
         */
    fetchHotspots?: FetchHotspotsFunction;
    /**
         * Defines maximum distance between tile and pointer, till which we keep alive unfinished requests
         * for hotspots for that tile.
         */
    hotspotAbortRadius?: number;
    /**
         * Defines how far inside into tile hotspots from other tile can go.
         * For example, tile may have a little part of POI from neightbour tile, but no hotspot for it in data.
         */
    hotspotInset?: number;
    /**
         * Defines how much pixels should be added to hotspot to increase its area.
         * Moves each point of hotspot X pixels away from the center of the hotspots.
         * NOTE: Currently works only on hotspots with Polygon geometry.
         */
    hotspotPadding?: number;
}
interface HotspotsOptions {
    minZoom?: number;
}
type MapTheme = 'dark';
type VectorTileSize = 'X1' | 'X4' | 'X16';
type VectorDataSourcePriority = 'low' | 'medium' | 'high';
type VectorObjectsCollisionPriority = 'low' | 'medium' | 'high' | 'ultra';
type VectorMapType = 'map' | 'driving' | 'transit' | 'admin' | 'future-map';
interface VectorTileDataSourceDescription {
    /** Default is `'vmap2'` */
    tileFormat?: 'vmap2' | 'vmap3';
    tileUrl: string;
    imageUrl?: string;
    meshUrl?: string;
    richModelUrl?: string;
    glyphRangeUrl?: string;
    indoorPlanUrl?: string;
    styleUrl?: string;
    fontListUrl?: string;
    fontObjectUrl?: string;
    tileRequestWithCredentials?: boolean;
    imageRequestWithCredentials?: boolean;
    meshRequestWithCredentials?: boolean;
    glyphRequestWithCredentials?: boolean;
    richModelRequestWithCredentials?: boolean;
    indoorPlanRequestWithCredentials?: boolean;
    styleRequestWithCredentials?: boolean;
    fontListRequestWithCredentials?: boolean;
    fontObjectRequestWithCredentials?: boolean;
    tileRequestHeaders?: Record<string, string>;
    iconRequestHeaders?: Record<string, string>;
    glyphRequestHeaders?: Record<string, string>;
    meshRequestHeaders?: Record<string, string>;
    richModelRequestHeaders?: Record<string, string>;
    indoorPlanRequestHeaders?: Record<string, string>;
    styleRequestHeaders?: Record<string, string>;
    fontListRequestHeaders?: Record<string, string>;
    fontObjectRequestHeaders?: Record<string, string>;
    priority: VectorDataSourcePriority;
    collisionPriority?: VectorObjectsCollisionPriority;
    requestTileSize?: VectorTileSize;
    tileBeltSize?: number;
    lowPrecisionBeltTiles?: boolean;
    tileCacheSize?: number;
    richModelCacheSize?: number;
    richModelEnabled?: boolean;
    richPointEnabled?: boolean;
    allObjectsInteractive?: boolean;
    /** Forces tiles to wait for the icons, disables hiding icons by zoom diff */
    iconsOnlyTiles?: boolean;
    /** Milliseconds */
    cameraIdleThrottling?: number;
    richModelDecoderWorkerUrl?: string;
    customization?: VectorCustomization;
    theme?: MapTheme;
    hdModeEnabled?: boolean;
    /** Defines how hotspots of type should be treated: enabled/disabled or use custom hotspots instead. */
    hotspots?: Record<string, boolean | FetchHotspotsFunction | HotspotsOptions>;
}
export { VectorCustomizationTypes, VectorCustomizationElements, VectorCustomizationItem, VectorCustomization, RasterTileDataSourceDescription, FetchHotspotsFunction, VectorTileDataSourceDescription, VectorTileSize, VectorObjectsCollisionPriority, VectorDataSourcePriority, VectorMapType, HotspotsOptions, FetchTileFunction, ComposeTileUrlFunction, Hotspot, WorldHotspot, RenderedHotspot, FetchedRasterTile, FetchedTile, FetchedCommonTile, MapTheme };
