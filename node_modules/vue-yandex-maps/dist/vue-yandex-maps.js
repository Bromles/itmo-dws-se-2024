import './vue-yandex-maps.css';var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { t as throwException, g as getException, c as createYmapsOptions, i as initYmaps, V as VueYandexMaps, s as setFragment, a as copy, e as excludeKeys, h as hVue2, b as hF, d as getAttrsForVueVersion, f as sleep, j as isVue2 } from "./vue-yandex-maps-D8zyDLVU.js";
import { getCurrentInstance, inject, isRef, watch, defineComponent, shallowRef, ref, provide, computed, onMounted, onBeforeUnmount, nextTick, h, onUpdated, triggerRef } from "vue";
function applyModifier(coords, modifier) {
  const result = {
    x: 0,
    y: 0
  };
  result.x = coords.x * modifier;
  result.y = coords.y * modifier;
  return result;
}
function applyFunctionModifier(coords, functionModifier) {
  const result = {
    x: 0,
    y: 0
  };
  result.x = functionModifier(coords.x, 1);
  result.y = functionModifier(coords.y, 2);
  return result;
}
function worldToPixels(coords, modifier) {
  const i = 2 ** modifier / 2 * 256;
  return applyModifier({
    x: coords.x + 1,
    y: 1 - coords.y
  }, i);
}
function convertWorldCoordinates(projection, coordinates, modifier) {
  const worldCoordinates = projection.toWorldCoordinates(coordinates);
  return worldToPixels(worldCoordinates, modifier);
}
function pixelsToWorld(coords, modifier) {
  const i = 2 ** modifier / 2 * 256;
  return {
    x: coords.x / i - 1,
    y: 1 - coords.y / i
  };
}
function findNeededValue(t, e, i) {
  return Math.max(Math.min(t, i), e);
}
function worldCoordsFromModifier(projection, coords, modifier) {
  const resultCoords = applyFunctionModifier(pixelsToWorld(coords, modifier), (value) => findNeededValue(value, -1, 1 - 1e-15));
  return projection.fromWorldCoordinates(resultCoords);
}
function convertBounds(projection, bounds, modifier) {
  const topLeft = convertWorldCoordinates(projection, bounds[0], modifier);
  const bottomRight = convertWorldCoordinates(projection, bounds[1], modifier);
  const modified = 2 ** modifier * 256;
  const updatedBounds = [[topLeft.x, topLeft.y], [bottomRight.x, bottomRight.y]];
  if (topLeft.x > bottomRight.x) {
    updatedBounds[0][0] = topLeft.x;
    updatedBounds[1][0] = bottomRight.x + modified;
  }
  if (topLeft.y > bottomRight.y) {
    updatedBounds[0][1] = bottomRight.y;
    updatedBounds[1][1] = topLeft.y;
  }
  return updatedBounds;
}
function applyMarginToCoords(coords, margin) {
  return {
    x: Math.max(coords.x - (margin ? margin[1] + margin[3] : 0), 1),
    y: Math.max(coords.y - (margin ? margin[0] + margin[2] : 0), 1)
  };
}
function findZoom(projection, bounds, coords, isSnap, zoomRange) {
  const [[topLeftFirst, topLeftSecond], [bottomRightFirst, bottomRightSecond]] = convertBounds(projection, bounds, 0);
  const firstCalc = Math.max(Math.abs(bottomRightFirst - topLeftFirst), 1e-10);
  const secondCalc = Math.max(Math.abs(bottomRightSecond - topLeftSecond), 1e-10);
  const zoom = findNeededValue(Math.min(Math.log2(coords.x / firstCalc), Math.log2(coords.y / secondCalc)), zoomRange.min, zoomRange.max);
  return isSnap ? Math.floor(zoom + 1e-6) : zoom;
}
function findCenter(projection, bounds, zoom) {
  const [[topLeftFirst, topLeftSecond], [bottomRightFirst, bottomRightSecond]] = convertBounds(projection, bounds, zoom);
  return worldCoordsFromModifier(projection, {
    x: (topLeftFirst + bottomRightFirst) / 2,
    y: (topLeftSecond + bottomRightSecond) / 2
  }, zoom);
}
async function getLocationFromBounds({
  bounds,
  map,
  roundZoom,
  comfortZoomLevel
}) {
  var _a;
  const ctxMap = Object.keys(map).find((x) => x.endsWith("CtxMap"));
  if (!ctxMap) {
    throwException({
      text: "CtxMap was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    });
  }
  const ctx = map[ctxMap];
  const ctxItem = await new Promise((resolve, reject) => {
    ctx.forEach((item, { name }) => {
      if (name !== "map") return;
      resolve(item);
    });
    reject(getException({
      text: "Map item was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    }));
  });
  const ctxItemMapKey = Object.keys(ctxItem).find((x) => x.endsWith("_context"));
  if (!ctxItemMapKey) {
    throwException({
      text: "CtxMapKey was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    });
  }
  const ctxItemMap = ctxItem[ctxItemMapKey].map;
  const boundsFunc = ctxItemMap.setBounds.toString();
  const funcKey = (_a = boundsFunc.split("const{center:e,zoom:i}=")[1]) == null ? void 0 : _a.split("(")[0];
  if (!funcKey) {
    throwException({
      text: "funcKey was not found in useYMapsGetCenterAndZoomFromBounds",
      isInternal: true
    });
  }
  const projection = ctxItemMap.projection;
  const size = ctxItemMap.size;
  const margin = ctxItemMap.margin;
  const isSnap = ctxItemMap.effectiveZoomRounding === "snap";
  const zoomRange = ctxItemMap.zoomRange;
  let zoom = findZoom(projection, bounds, applyMarginToCoords(size, margin), isSnap, zoomRange);
  const center = findCenter(projection, bounds, zoom);
  if (roundZoom || comfortZoomLevel) {
    const originalZoom = zoom;
    let roundedZoom = Math[typeof roundZoom === "string" ? roundZoom : "floor"](zoom);
    if (roundZoom) zoom = roundedZoom;
    if (comfortZoomLevel) {
      const userSettings = typeof comfortZoomLevel === "object" ? comfortZoomLevel : {};
      if (userSettings.roundStrategy) roundedZoom = Math[userSettings.roundStrategy](originalZoom);
      const diff2 = originalZoom - roundedZoom;
      const settings = {
        diff: 0.5,
        correction: 1,
        ...userSettings
      };
      if (diff2 < settings.diff) {
        zoom -= settings.correction;
      }
    }
  }
  return {
    zoom,
    center
  };
}
const useYMapsLocationFromBounds = getLocationFromBounds;
function getCenterFromCoords(coordinates) {
  if (coordinates.length === 1) return coordinates[0];
  if (!coordinates.length) {
    throwException({
      text: "Invalid parameters in getCenterFromCoords: you must pass at least one LngLat"
    });
  }
  const sum = coordinates.reduce(([accLng, accLat], [lng, lat]) => [
    accLng + lng,
    accLat + lat
  ], [0, 0]);
  return [
    sum[0] / coordinates.length,
    sum[1] / coordinates.length
  ];
}
function getBoundsFromCoords(coordinates) {
  if (coordinates.length < 2) {
    throwException({
      text: "Invalid parameters in getBoundsFromCoords: you must pass at least two LngLat"
    });
  }
  const {
    minLongitude,
    minLatitude,
    maxLongitude,
    maxLatitude
  } = coordinates.reduce(
    (acc, [longitude, latitude]) => ({
      minLongitude: Math.min(acc.minLongitude, longitude),
      minLatitude: Math.min(acc.minLatitude, latitude),
      maxLongitude: Math.max(acc.maxLongitude, longitude),
      maxLatitude: Math.max(acc.maxLatitude, latitude)
    }),
    {
      minLongitude: Infinity,
      minLatitude: Infinity,
      maxLongitude: -Infinity,
      maxLatitude: -Infinity
    }
  );
  return [[minLongitude, minLatitude], [maxLongitude, maxLatitude]];
}
function createYmaps(settings) {
  return {
    install(app) {
      createYmapsOptions(settings);
      if (settings.initializeOn === "onPluginInit") {
        initYmaps().catch(console.error);
      }
    }
  };
}
function createYmapsVue2(settings) {
  return {
    install(Vue) {
      createYmapsOptions(settings);
      if (settings.initializeOn === "onPluginInit") {
        initYmaps().catch(console.error);
      }
    }
  };
}
const isDate = (d) => d instanceof Date;
const isEmpty = (o) => Object.keys(o).length === 0;
const isObject = (o) => o != null && typeof o === "object";
const hasOwnProperty = (o, ...args) => Object.prototype.hasOwnProperty.call(o, ...args);
const isEmptyObject = (o) => isObject(o) && isEmpty(o);
const makeObjectWithoutPrototype = () => /* @__PURE__ */ Object.create(null);
const diff = (lhs, rhs) => {
  if (lhs === rhs) return {};
  if (!isObject(lhs) || !isObject(rhs)) return rhs;
  const deletedValues = Object.keys(lhs).reduce((acc, key) => {
    if (!hasOwnProperty(rhs, key)) {
      acc[key] = void 0;
    }
    return acc;
  }, makeObjectWithoutPrototype());
  if (isDate(lhs) || isDate(rhs)) {
    if (lhs.valueOf() == rhs.valueOf()) return {};
    return rhs;
  }
  return Object.keys(rhs).reduce((acc, key) => {
    if (!hasOwnProperty(lhs, key)) {
      acc[key] = rhs[key];
      return acc;
    }
    const difference = diff(lhs[key], rhs[key]);
    if (isEmptyObject(difference) && !isDate(difference) && (isEmptyObject(lhs[key]) || !isEmptyObject(rhs[key])))
      return acc;
    acc[key] = difference;
    return acc;
  }, deletedValues);
};
function injectMap() {
  if (!getCurrentInstance()) {
    throwException({
      text: "injectMap must be only called on runtime.",
      isInternal: true
    });
  }
  const map = inject("map");
  if (!map || !isRef(map)) {
    throwException({
      text: "Was not able to inject valid map in injectMap.",
      isInternal: true
    });
  }
  return map;
}
function injectLayers() {
  if (!getCurrentInstance()) {
    throwException({
      text: "injectLayers must be only called on runtime.",
      isInternal: true
    });
  }
  const layers = inject("layers");
  if (!layers || !isRef(layers)) {
    throwException({
      text: "Was not able to inject valid layers in injectLayers.",
      isInternal: true
    });
  }
  return layers;
}
async function waitTillYmapInit({
  timeoutCallback,
  waitDuration
} = {}) {
  if (typeof window === "undefined") {
    throwException({
      text: "waitTillYmapInit cannot be called on SSR.",
      isInternal: true
    });
  }
  if (typeof ymaps3 !== "undefined") return;
  return new Promise((resolve, reject) => {
    if (typeof ymaps3 === "undefined") {
      let timeout;
      waitDuration = typeof waitDuration !== "undefined" ? waitDuration : VueYandexMaps.settings.value.mapsScriptWaitDuration;
      if (waitDuration !== false) {
        timeout = setTimeout(() => {
          timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
          reject(new VueYandexMaps.YandexMapException("Was not able to wait for map initialization in waitTillYmapInit. Ensure that map was initialized. You can change this behavior by using mapsScriptWaitDuration."));
        }, typeof waitDuration === "number" ? waitDuration : 5e3);
        timeoutCallback == null ? void 0 : timeoutCallback(timeout, false);
      }
      watch(VueYandexMaps.isLoaded, () => {
        if (timeout) {
          clearTimeout(timeout);
          timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
        }
        if (VueYandexMaps.loadStatus.value === "loaded") {
          resolve();
        } else {
          reject(VueYandexMaps.loadError);
        }
      }, {
        immediate: true
      });
    } else {
      resolve();
    }
  });
}
async function waitTillMapInit({
  map: _map,
  timeoutCallback,
  waitDuration
} = {}) {
  if (!_map && !getCurrentInstance()) {
    throwException({
      text: "onMapInit must be only called on runtime.",
      isInternal: true
    });
  }
  if (typeof window === "undefined") {
    throwException({
      text: "waitTillMapInit cannot be called on SSR.",
      isInternal: true
    });
  }
  const map = _map || injectMap();
  if (map.value) return;
  return new Promise((resolve, reject) => {
    let timeout;
    waitDuration = typeof waitDuration !== "undefined" ? waitDuration : VueYandexMaps.settings.value.mapsRenderWaitDuration;
    if (waitDuration !== false) {
      timeout = setTimeout(() => {
        timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
        reject(new VueYandexMaps.YandexMapException("Was not able to wait for map initialization in waitTillMapInit. You can change this behavior by using mapsRenderWaitDuration."));
      }, typeof waitDuration === "number" ? waitDuration : 5e3);
      timeoutCallback == null ? void 0 : timeoutCallback(timeout, false);
    }
    let watcher;
    watcher = watch(map, () => {
      if (map.value) {
        watcher == null ? void 0 : watcher();
        if (timeout) {
          clearTimeout(timeout);
          timeoutCallback == null ? void 0 : timeoutCallback(timeout, true);
        }
        resolve();
      }
    }, {
      immediate: true
    });
  });
}
function deleteMapChild({
  children,
  isMercator,
  root
}) {
  var _a;
  if (!root) {
    throwException({
      text: "Failed to execute deleteMapChild due to destroyed root",
      isInternal: true
    });
  }
  if (children && !isMercator) {
    if (typeof (root == null ? void 0 : root.value) === "object" && Array.isArray(root.value)) {
      root.value = root.value.filter((x) => x !== children);
    } else {
      (_a = root.value) == null ? void 0 : _a.removeChild(children);
    }
  } else if (root.value && children && isMercator && "update" in root.value) {
    root.value.update({
      projection: void 0
    });
  }
}
const _sfc_main$q = defineComponent({
  name: "YandexMap",
  props: {
    modelValue: {
      type: Object,
      default: null
    },
    value: {
      type: Object,
      default: null
    },
    tag: {
      type: String,
      default: "div"
    },
    width: {
      type: String,
      default: "100%"
    },
    height: {
      type: String,
      default: "100%"
    },
    // z-index for Map Container. Without this, elements of the map will be displayed under your site's elements due to high z-index inside of them
    zIndex: {
      type: Number,
      default: 0
    },
    /**
    * @description Settings for cart initialization.,
    *
    * You can modify this object or use map methods, such as setLocation/setBehaviors e.t.c.
    * @see https://yandex.ru/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#map-parms
    * @see https://yandex.com/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#map-parms
    */
    settings: {
      type: Object,
      required: true
    },
    /**
    * @description Makes settings readonly. Enable this if reactivity causes problems
    */
    readonlySettings: {
      type: Boolean,
      default: false
    },
    /**
    * @description Always inserts actual user center or bounds (based on your input) on every location change
    * @note This prop will cause user location change on every settings update (if user did move since last time). Use it with caution.
    */
    realSettingsLocation: {
      type: Boolean,
      default: false
    },
    /**
    * @description You can also add layers through <yandex-*> components
    *
    * Modifying this object after mount will cause no effect.
    *
    * Instead, please use map methods, such as addChild.
    * @see https://yandex.ru/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#layers
    * @see https://yandex.com/dev/maps/jsapi/doc/3.0/dg/concepts/map.html#layers
    */
    layers: {
      type: Array,
      default: () => []
    },
    /**
    * @description Adds cursor: grab/grabbing to ymaps scheme layer
    */
    cursorGrab: {
      type: Boolean,
      default: false
    }
  },
  /**
  * @description Other events are NOT available. You can listen to events via layers prop, addChildren prop or by adding <ymap-listener> as children.
  * @see https://yandex.ru/dev/maps/jsapi/doc/3.0/dg/concepts/events.html
  * @see https://yandex.com/dev/maps/jsapi/doc/3.0/dg/concepts/events.html
  */
  emits: {
    "input"(map) {
      return !map || typeof ymaps3 === "undefined" || map instanceof ymaps3.YMap;
    },
    "update:modelValue"(map) {
      return !map || typeof ymaps3 === "undefined" || map instanceof ymaps3.YMap;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const map = shallowRef(null);
    const mapRef = shallowRef(null);
    const layers = shallowRef([]);
    const projection = shallowRef(null);
    const ymapContainer = shallowRef(null);
    const mounted = shallowRef(false);
    const needsToHold = ref(0);
    provide("map", map);
    provide("layers", layers);
    provide("projection", projection);
    provide("needsToHold", needsToHold);
    emit("input", null);
    emit("update:modelValue", null);
    const getSettings = computed(() => ({
      ...props.settings,
      projection: void 0
    }));
    const init = async () => {
      if (!props.settings.location) {
        throwException({
          text: "You must specify location in YandexMap settings"
        });
      }
      if (map.value) map.value.destroy();
      const container = ymapContainer.value;
      if (!container) return;
      const settings = getSettings.value;
      if (projection.value) settings.projection = projection.value;
      map.value = new ymaps3.YMap(container, settings, [
        ...layers.value,
        ...props.layers
      ]);
      emit("input", map.value);
      emit("update:modelValue", map.value);
    };
    onMounted(async () => {
      let listener;
      let watcher;
      let cursorGrabTimeout = null;
      onBeforeUnmount(() => {
        if (cursorGrabTimeout) clearTimeout(cursorGrabTimeout);
      });
      const setupWatcher = () => {
        watcher == null ? void 0 : watcher();
        let settings = copy(getSettings);
        watcher = watch(getSettings, (val) => {
          var _a;
          if (!map.value) return;
          const clonedSettings = copy(val);
          if (props.realSettingsLocation && clonedSettings.location) {
            if ("center" in clonedSettings.location && "center" in settings.location) {
              settings.location.center = map.value.center;
            } else if ("bounds" in clonedSettings.location && "bounds" in settings.location) {
              settings.location.bounds = map.value.bounds;
            }
            if ("zoom" in clonedSettings.location && "zoom" in settings.location) settings.location.zoom = map.value.zoom;
          }
          const settingsDiff = Object.keys(diff(settings, clonedSettings));
          if (settingsDiff.length === 0) return;
          const updatedSettings = { ...clonedSettings };
          for (const key in updatedSettings) {
            if (!settingsDiff.includes(key)) delete updatedSettings[key];
          }
          settings = clonedSettings;
          (_a = map.value) == null ? void 0 : _a.update(updatedSettings);
        }, {
          deep: true
        });
      };
      if (!props.readonlySettings) {
        setupWatcher();
      }
      watch(() => props.readonlySettings, (val) => {
        if (!val) {
          watcher == null ? void 0 : watcher();
        } else {
          setupWatcher();
        }
      });
      watch(() => props.cursorGrab, async (val) => {
        await waitTillMapInit({
          map,
          timeoutCallback: (_timeout, isDelete) => {
            if (isDelete) {
              cursorGrabTimeout = null;
            } else {
              cursorGrabTimeout = _timeout;
            }
          }
        }).catch(() => {
        });
        if (!map.value) return;
        if (val) {
          listener = new ymaps3.YMapListener({
            onActionStart: (e) => {
              var _a;
              if (e.type === "drag" && props.cursorGrab) (_a = mapRef.value) == null ? void 0 : _a.classList.add("__ymap--grabbing");
            },
            onActionEnd: (e) => {
              var _a;
              if (e.type === "drag") (_a = mapRef.value) == null ? void 0 : _a.classList.remove("__ymap--grabbing");
            }
          });
          map.value.addChild(listener);
        } else if (listener) map.value.removeChild(listener);
      }, { immediate: true });
      await setFragment();
      if (!VueYandexMaps.isLoaded.value) {
        if (VueYandexMaps.settings.value.initializeOn === "onComponentMount") {
          try {
            await initYmaps();
          } catch (e) {
            console.error("An error occured while initializing Yandex Map with onComponentMount setting");
            console.error(e);
            return;
          }
        } else if (VueYandexMaps.loadStatus.value === "loading" || VueYandexMaps.settings.value.initializeOn === "onPluginInit") {
          if (VueYandexMaps.settings.value.initializeOn === "onPluginInit" && VueYandexMaps.loadStatus.value !== "loading") await nextTick();
          await initYmaps();
        }
        if (!VueYandexMaps.isLoaded.value) {
          throwException({
            text: "You have set up <yandex-map> component without initializing Yandex maps. Please check initializeOn setting or call initYmaps manually before registering this component."
          });
        }
      }
      mounted.value = true;
      await nextTick();
      if (needsToHold.value) {
        await new Promise((resolve) => watch(needsToHold, () => {
          if (!needsToHold.value) resolve();
        }, {
          immediate: true
        }));
      }
      await init();
    });
    onBeforeUnmount(() => {
      map.value = null;
      emit("input", map.value);
      emit("update:modelValue", map.value);
    });
    return () => {
      var _a;
      const mapNodeProps = {
        class: [
          "__ymap",
          {
            "__ymap--grab": props.cursorGrab
          }
        ],
        ref: mapRef,
        style: {
          width: props.width,
          height: props.height,
          "z-index": props.zIndex.toString()
        }
      };
      const containerNode = h("div", {
        class: "__ymap_container",
        ref: ymapContainer
      });
      const slotsNodeProps = {
        class: "__ymap_slots",
        style: { display: "none" }
      };
      if (!mounted.value) return h(props.tag, mapNodeProps, [containerNode, h("div", slotsNodeProps)]);
      return h(props.tag, mapNodeProps, [
        containerNode,
        h("div", slotsNodeProps, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
      ]);
    };
  }
});
async function setupMapChildren({
  returnOnly,
  willDeleteByHand,
  strictMapRoot,
  requiredImport,
  createFunction,
  settings,
  settingsUpdateIgnoreKeys,
  isLayer,
  isMercator,
  isMapRoot,
  mapRootRef,
  duplicateInit
}) {
  if (!getCurrentInstance()) {
    throwException({
      text: "setupMapChildren must be only called on runtime.",
      isInternal: true
    });
  }
  const children = shallowRef();
  const mapRoot = inject("mapRoot", null);
  const initPromises = inject("mapRootInitPromises", null);
  let childrenPromises;
  const map = injectMap();
  const layers = injectLayers();
  let timeouts = null;
  const timeoutCallback = (timeout, isDelete) => {
    if (!timeouts) timeouts = /* @__PURE__ */ new Set();
    if (!isDelete) timeouts.add(timeout);
    else timeouts.delete(timeout);
  };
  if (isMapRoot && !duplicateInit) {
    provide("mapRoot", mapRootRef || children);
    childrenPromises = shallowRef([]);
    provide("mapRootInitPromises", childrenPromises);
  }
  if (!returnOnly && !willDeleteByHand) {
    onBeforeUnmount(() => {
      if (children.value) {
        deleteMapChild({
          children: children.value,
          isMercator,
          root: (mapRoot == null ? void 0 : mapRoot.value) ? mapRoot : map
        });
      }
      if (timeouts == null ? void 0 : timeouts.size) {
        timeouts.forEach((timeout) => clearTimeout(timeout));
        timeouts.clear();
      }
    });
  }
  if (settings) {
    let lastSettings = copy(settings);
    watch(settings, (value) => {
      if (!value) return;
      const settingsDiff = Object.keys(diff(lastSettings, value));
      if (settingsDiff.length === 0) return;
      const updatedSettings = copy(value);
      for (const key in updatedSettings) {
        if (!settingsDiff.includes(key)) delete updatedSettings[key];
      }
      const ignoreKeys = settingsUpdateIgnoreKeys && (isRef(settingsUpdateIgnoreKeys) ? settingsUpdateIgnoreKeys.value : settingsUpdateIgnoreKeys);
      if (ignoreKeys) excludeKeys(updatedSettings, ignoreKeys);
      if (Object.keys(updatedSettings).length === 0) return;
      lastSettings = copy(value);
      if (children.value && "update" in children.value) children.value.update(updatedSettings);
    }, { deep: true });
  }
  if (!isLayer && !isMercator) {
    await waitTillMapInit({ timeoutCallback });
    if (!map.value) {
      throwException({
        text: "map is undefined in setupMapChildren. Please verify that Yandex Maps were initialized successfully and you only use components inside <yandex-map>."
      });
    }
  } else {
    await waitTillYmapInit({ timeoutCallback });
  }
  if (strictMapRoot) {
    if (!(mapRoot == null ? void 0 : mapRoot.value)) await nextTick();
    if (!(mapRoot == null ? void 0 : mapRoot.value)) {
      throwException({
        text: `mapRoot is undefined in setupMapChildren. Please verify that you are using component inside it's root: for example, don't use Controls outside <yandex-map-controls>.`
      });
    }
  }
  if (isMapRoot) {
    await nextTick();
    await Promise.all((childrenPromises == null ? void 0 : childrenPromises.value) || []);
  }
  let importData;
  if (requiredImport) {
    const importPromise = requiredImport();
    if (initPromises == null ? void 0 : initPromises.value) initPromises.value.push(Promise.resolve(importPromise));
    importData = await importPromise;
  }
  children.value = createFunction(importData);
  if (!returnOnly && map.value && !isMercator) {
    if (initPromises == null ? void 0 : initPromises.value) {
      await Promise.all(initPromises.value);
      if (!requiredImport) await nextTick();
    }
    if (typeof (mapRoot == null ? void 0 : mapRoot.value) === "object" && Array.isArray(mapRoot.value)) {
      mapRoot.value = [
        ...mapRoot.value,
        children.value
      ];
    } else {
      ((mapRoot == null ? void 0 : mapRoot.value) || map.value).addChild(children.value);
    }
  } else if (isLayer) {
    layers.value.push(children.value);
  } else if (isMercator && map.value) {
    map.value.update({
      projection: children.value
    });
  }
  return children.value;
}
const _sfc_main$p = defineComponent({
  name: "YandexMapListener",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapListener;
    onMounted(async () => {
      mapListener = await setupMapChildren({
        createFunction: () => new ymaps3.YMapListener(props.settings || {}),
        settings: computed(() => props.settings)
      });
      emit("input", mapListener);
      emit("update:modelValue", mapListener);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$o = defineComponent({
  name: "YandexMapDefaultFeaturesLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapDefaultFeaturesLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$n = defineComponent({
  name: "YandexMapDefaultSchemeLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapDefaultSchemeLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return (_a = slots.default) == null ? void 0 : _a.call(slots, {});
    };
  }
});
const _sfc_main$m = defineComponent({
  name: "YandexMapDefaultSatelliteLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapDefaultSatelliteLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$l = defineComponent({
  name: "YandexMapTileDataSource",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapChildren;
    onMounted(async () => {
      if (!props.settings.id) {
        throwException({
          text: "You must specify id in YandexMapTileDataSource settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapTileDataSource(props.settings),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$k = defineComponent({
  name: "YandexMapFeatureDataSource",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapChildren;
    onMounted(async () => {
      if (!props.settings.id) {
        throwException({
          text: "You must specify id in YandexMapFeatureDataSource settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapFeatureDataSource(props.settings),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$j = defineComponent({
  name: "YandexMapLayer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    let mapLayer;
    onMounted(async () => {
      if (!props.settings.type) {
        throwException({
          text: "You must specify type in YandexMapLayer settings"
        });
      }
      mapLayer = await setupMapChildren({
        createFunction: () => new ymaps3.YMapLayer(props.settings || {}),
        settings: computed(() => props.settings),
        isLayer: true
      });
      emit("input", mapLayer);
      emit("update:modelValue", mapLayer);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
function getMarkerContainerProps({
  position,
  containerAttrs,
  wrapperAttrs,
  zeroSizes
}) {
  const root = {
    class: ["__ymap-marker"],
    style: {}
  };
  const children = {
    class: ["__ymap-marker_wrapper"],
    style: {}
  };
  const isDefaultPosition = position === "default" || position === "default default";
  if (position && !isDefaultPosition) {
    if (position.startsWith("translate")) {
      children.style.transform = position;
    } else {
      let translateX = 0;
      let translateY = 0;
      const splitted = position.split(" ");
      for (let i = 0; i < splitted.length; i++) {
        let local = 0;
        const item = splitted[i];
        switch (item) {
          case "top":
          case "left":
            local = -100;
            break;
          case "top-center":
          case "left-center":
            local = -50;
            break;
          case "bottom":
          case "right":
            local = 100;
            break;
          case "bottom-center":
          case "right-center":
            local = 50;
            break;
          default:
            local = 0;
        }
        if (item.startsWith("left") || item.startsWith("right")) translateX = local;
        else translateY = local;
      }
      children.style.transform = `translate(${translateX}%, ${translateY}%)`;
    }
  }
  if (zeroSizes === true || zeroSizes !== false && position && !isDefaultPosition) {
    root.style.width = "0";
    root.style.height = "0";
    if (children.style.transform) children.style.width = "fit-content";
  }
  const attrs = {
    root: { ...containerAttrs ?? {} },
    children: { ...wrapperAttrs ?? {} }
  };
  for (const [key, value] of Object.entries(attrs)) {
    const obj = key === "root" ? root : children;
    if (value.class) {
      if (!Array.isArray(value.class)) value.class = [value.class];
      value.class = [
        ...obj.class,
        ...value.class
      ];
    }
    if (value == null ? void 0 : value.style) {
      if (typeof value.style !== "object" || Array.isArray(value.style)) {
        console.warn(`Style property was given in ${key} of marker, but it is not an object. Style of this prop can only be an object, therefore it was ignored.`);
      } else {
        value.style = {
          ...obj.style,
          ...value.style
        };
      }
    }
    Object.assign(obj, value);
  }
  return {
    root,
    children
  };
}
function excludeYandexMarkerProps(props) {
  props = { ...props };
  const toExclude = {
    position: true,
    containerAttrs: true,
    wrapperAttrs: true,
    zeroSizes: true
  };
  for (const excluded in toExclude) {
    if (excluded in props) delete props[excluded];
  }
  return props;
}
const _sfc_main$i = defineComponent({
  name: "YandexMapMarker",
  inheritAttrs: false,
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    },
    /**
    * @description Sets translate(%, %) to marker to align it properly.
    *
    * If you want to make aligment to be like Yandex Maps 2.0, set this property to "top left-center".
    * @default default (as goes in Yandex by default)
    */
    position: {
      type: String
    },
    /**
    * @description Allows you to add any attributes to <div class="__ymap-marker"> container.
    *
    * Important: to pass styles, you must use object-style prop instead of string.
    */
    containerAttrs: {
      type: Object,
      default: () => ({})
    },
    /**
    * @description Allows you to add any attributes to <div class="__ymap-marker_wrapper"> container.
    *
    * Important: to pass styles, you must use object-style prop instead of string.
    */
    wrapperAttrs: {
      type: Object,
      default: () => ({})
    },
    /**
    * @description Will add width and height: 0 to container.
    *
    * Null enables default behavior, false disables it completely (even if position is specified).
    *
    * @default true if position is specified, false otherwise
    */
    zeroSizes: {
      type: Boolean,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const element = ref(null);
    function clearElement() {
      var _a, _b, _c;
      if (!((_b = (_a = element.value) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.closest("ymaps"))) (_c = element.value) == null ? void 0 : _c.remove();
    }
    onMounted(async () => {
      if (!props.settings.coordinates) {
        throwException({
          text: "You must specify coordinates in YandexMapMarker settings"
        });
      }
      mapChildren = await setupMapChildren({
        settings: computed(() => props.settings),
        createFunction: () => new ymaps3.YMapMarker(props.settings, element.value)
      });
      clearElement();
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    let mapParent = void 0;
    onUpdated(() => {
      var _a, _b, _c, _d;
      if (!mapParent && ((_b = (_a = element.value) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.closest("ymaps"))) mapParent = element.value.parentElement;
      else if (mapParent && element.value && !((_d = (_c = element.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.closest("ymaps"))) mapParent.appendChild(element.value);
      clearElement();
    });
    const rootProps = computed(() => getMarkerContainerProps({
      position: props.position,
      containerAttrs: props.containerAttrs,
      wrapperAttrs: props.wrapperAttrs,
      zeroSizes: props.zeroSizes
    }));
    return () => {
      var _a;
      return hF([
        h("div", {
          ...rootProps.value.root,
          ref: element,
          ...getAttrsForVueVersion(attrs)
        }, [
          h("div", {
            ...rootProps.value.children
          }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
        ])
      ]);
    };
  }
});
const _sfc_main$h = defineComponent({
  name: "YandexMapDefaultMarker",
  inheritAttrs: false,
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const popup = ref(null);
    const closeFunc = ref(() => {
    });
    const contentFunc = (close) => {
      closeFunc.value = close;
      return popup.value;
    };
    const getSettings = computed(() => {
      const settings = { ...props.settings };
      if (settings.popup && (typeof settings.popup.content === "undefined" || settings.popup.content === "fromSlot") && popup.value) {
        settings.popup = {
          ...settings.popup,
          content: contentFunc
        };
      }
      return settings;
    });
    onMounted(async () => {
      if (!props.settings.coordinates) {
        throwException({
          text: "You must specify coordinates in YandexMapDefaultMarker settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: ({ YMapDefaultMarker: Marker }) => new Marker(getSettings.value),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-markers@0.0.1"),
        settings: getSettings
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    watch(popup, () => {
      var _a;
      if (popup.value) (_a = popup.value.parentNode) == null ? void 0 : _a.removeChild(popup.value);
    });
    return () => {
      var _a;
      if (slots.popup) {
        return hF([
          h("div", {
            ref: popup
          }, (_a = slots.popup) == null ? void 0 : _a.call(slots, { close: closeFunc.value }))
        ]);
      }
      return void 0;
    };
  }
});
const _sfc_main$g = defineComponent({
  name: "YandexMapFeature",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      if (!props.settings.geometry) {
        throwException({
          text: "You must specify geometry in YandexMapFeature settings"
        });
      }
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapFeature(props.settings),
        settings: computed(() => props.settings)
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$f = defineComponent({
  name: "YandexMapControls",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const mapChildren = shallowRef(null);
    onMounted(async () => {
      if (!props.settings.position) {
        throwException({
          text: "You must specify position in YandexMapControls settings"
        });
      }
      mapChildren.value = await setupMapChildren({
        createFunction: () => new ymaps3.YMapControls(props.settings),
        isMapRoot: true,
        settings: computed(() => props.settings)
      });
      emit("input", mapChildren.value);
      emit("update:modelValue", mapChildren.value);
    });
    return () => {
      var _a;
      return mapChildren.value ? hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {})) : h("div");
    };
  }
});
const _sfc_main$e = defineComponent({
  name: "YandexMapControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapControl(props.settings, element.value),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hF([
        h("div", {
          ref: element,
          ...getAttrsForVueVersion(attrs)
        }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
      ]);
    };
  }
});
const _sfc_main$d = defineComponent({
  name: "YandexMapControlButton",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapControlButton({
          ...props.settings,
          element: element.value
        }),
        settings: computed(() => ({
          ...props.settings,
          element: element.value
        })),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hF([
        h("div", {
          ref: element,
          ...getAttrsForVueVersion(attrs)
        }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
      ]);
    };
  }
});
const _sfc_main$c = defineComponent({
  name: "YandexMapGeolocationControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: (controls) => new controls.YMapGeolocationControl(props.settings),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-controls@0.0.1"),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$b = defineComponent({
  name: "YandexMapZoomControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: (controls) => new controls.YMapZoomControl(props.settings),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-controls@0.0.1"),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$a = defineComponent({
  name: "YandexMapScaleControl",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => new ymaps3.YMapScaleControl(props.settings),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$9 = defineComponent({
  name: "YandexMapCartesianProjection",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    bounds: {
      type: Array,
      required: true
    },
    cycled: {
      type: Array
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    const projection = inject("projection");
    onMounted(async () => {
      if (!projection) return;
      const cartesian = await setupMapChildren({
        isMercator: true,
        createFunction: ({ Cartesian: CartesianClass }) => new CartesianClass(props.bounds, props.cycled),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-cartesian-projection@0.0.1")
      });
      projection.value = cartesian;
      emit("input", cartesian);
      emit("update:modelValue", cartesian);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$8 = defineComponent({
  name: "YandexMapSphericalMercatorProjection",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const hold = inject("needsToHold");
    hold.value++;
    const projection = inject("projection");
    onMounted(async () => {
      if (!projection) {
        hold.value--;
        return;
      }
      const mercator = await setupMapChildren({
        isMercator: true,
        createFunction: ({ SphericalMercator: Mercator }) => new Mercator(),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-spherical-mercator-projection@0.0.1")
      });
      projection.value = mercator;
      emit("input", mercator);
      emit("update:modelValue", mercator);
      hold.value--;
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$7 = defineComponent({
  name: "YandexMapHint",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    // Property that you will set on YandexMapMarker or YandexMapFeature to display hint content
    hintProperty: {
      type: String,
      required: true
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const element = shallowRef(null);
    const hintContent = shallowRef("");
    onMounted(async () => {
      await setupMapChildren({
        createFunction: ({
          YMapHint: MapHint,
          YMapHintContext
        }) => {
          mapChildren = new MapHint({
            hint: (object) => {
              var _a;
              return (_a = object == null ? void 0 : object.properties) == null ? void 0 : _a[props.hintProperty];
            }
          });
          class Hint extends ymaps3.YMapEntity {
            _onAttach() {
              const e = this;
              e._element = element.value;
              e._detachDom = ymaps3.useDomContext(e, e._element, null);
              e._watchContext(YMapHintContext, () => {
                var _a;
                hintContent.value = (_a = e._consumeContext(YMapHintContext)) == null ? void 0 : _a[props.hintProperty];
              }, { immediate: true });
            }
            _onDetach() {
              this._detachDom();
            }
          }
          mapChildren.addChild(new Hint({}));
          return mapChildren;
        },
        requiredImport: () => ymaps3.import("@yandex/ymaps3-hint@0.0.1")
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hF([
        h("div", {
          ref: element,
          ...getAttrsForVueVersion(attrs)
        }, (_a = slots.default) == null ? void 0 : _a.call(slots, { content: hintContent.value }))
      ]);
    };
  }
});
const _sfc_main$6 = defineComponent({
  name: "YandexMapOpenMapsButton",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: ({ YMapOpenMapsButton: OpenMapsButton }) => new OpenMapsButton(props.settings),
        requiredImport: () => ymaps3.import("@yandex/ymaps3-controls-extra"),
        settings: computed(() => props.settings),
        strictMapRoot: true
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
    };
  }
});
const _sfc_main$5 = defineComponent({
  name: "YandexMapClustererCluster",
  props: {
    clusterMarkerProps: {
      type: Object,
      default: () => ({})
    },
    zoomOnClusterClick: {
      type: [Boolean, Object],
      default: false
    },
    feature: {
      type: Object,
      required: true
    }
  },
  emits: {
    // Exact features bounds returned on cluster click
    trueBounds(bounds) {
      return bounds.length === 2;
    },
    // Auto-corrected features bounds returned on cluster click
    updatedBounds(bounds) {
      return bounds.length === 2;
    },
    updatedCluster(clusterId) {
      return true;
    }
  },
  slots: Object,
  setup(props, { slots, emit }) {
    const map = injectMap();
    const element = ref(null);
    const containerProps = computed(() => {
      var _a, _b, _c, _d;
      return getMarkerContainerProps({
        position: ((_a = props.clusterMarkerProps) == null ? void 0 : _a.position) ?? "top-center left-center",
        containerAttrs: (_b = props.clusterMarkerProps) == null ? void 0 : _b.containerAttrs,
        wrapperAttrs: (_c = props.clusterMarkerProps) == null ? void 0 : _c.wrapperAttrs,
        zeroSizes: (_d = props.clusterMarkerProps) == null ? void 0 : _d.zeroSizes
      });
    });
    function updateElement() {
      const _element = element.value;
      if (!_element) return;
      const clusterElement = props.feature.element;
      const clusterer = props.feature.clusterer;
      if (clusterElement.children.length) {
        clusterElement.children.forEach((x) => {
          try {
            clusterElement.removeChild(x);
          } catch (e) {
            console.warn("Non-fatal error occurred when updating Map clusterer", e);
          }
        });
      }
      try {
        clusterElement.addChild(new ymaps3.YMapMarker({
          ...excludeYandexMarkerProps(props.clusterMarkerProps),
          coordinates: clusterer.lnglat,
          onClick: async (event, mapEvent) => {
            var _a, _b, _c, _d;
            (_b = (_a = props.clusterMarkerProps).onClick) == null ? void 0 : _b.call(_a, event, mapEvent);
            if (clusterer.features.length >= 2) {
              const settings = typeof props.zoomOnClusterClick === "object" ? props.zoomOnClusterClick : {};
              const featuresCoords = clusterer.features.map((x) => x.geometry.coordinates);
              const bounds = getBoundsFromCoords(featuresCoords);
              emit("trueBounds", bounds);
              if (!props.zoomOnClusterClick) return;
              const defaultDuration = settings.duration ?? 500;
              if (settings.strategy === "boundsCorrect") {
                const [[minLongitude, maxLatitude], [maxLongitude, minLatitude]] = bounds;
                const latDiff = maxLatitude - minLatitude;
                const longDiff = maxLongitude - minLongitude;
                const updatedBounds = [[minLongitude - longDiff, maxLatitude - latDiff], [maxLongitude + longDiff, minLatitude + latDiff]];
                emit("updatedBounds", updatedBounds);
                (_c = map.value) == null ? void 0 : _c.setLocation({
                  bounds: updatedBounds,
                  duration: defaultDuration,
                  easing: settings.easing
                });
              } else {
                const { center, zoom } = await getLocationFromBounds({
                  bounds,
                  map: map.value,
                  roundZoom: true,
                  comfortZoomLevel: true
                });
                (_d = map.value) == null ? void 0 : _d.setLocation({
                  center,
                  zoom,
                  duration: defaultDuration,
                  easing: settings.easing
                });
                await sleep(defaultDuration + 50);
                if (map.value) emit("updatedBounds", map.value.bounds);
              }
            }
          }
        }, _element));
      } catch (e) {
        console.error(e);
      }
    }
    watch(element, updateElement);
    const firstUpdate = ref(false);
    onUpdated(() => {
      if (!firstUpdate.value) {
        firstUpdate.value = true;
        return;
      }
      emit("updatedCluster", props.feature.clusterer.clusterId);
    });
    return () => {
      var _a;
      return hF([
        h("div", {
          ...containerProps.value.root,
          ref: element
        }, [
          h("div", containerProps.value.children, (_a = slots.default) == null ? void 0 : _a.call(slots, {
            clusterer: props.feature.clusterer,
            coordinates: props.feature.clusterer.lnglat,
            length: props.feature.clusterer.features.length
          }))
        ])
      ]);
    };
  }
});
const _sfc_main$4 = defineComponent({
  name: "YandexMapClustererClusters",
  props: {
    clusterMarkerProps: {
      type: Object,
      default: () => ({})
    },
    zoomOnClusterClick: {
      type: [Boolean, Object],
      default: false
    }
  },
  emits: {
    // Exact features bounds returned on cluster click
    trueBounds(bounds) {
      return bounds.length === 2;
    },
    // Auto-corrected features bounds returned on cluster click
    updatedBounds(bounds) {
      return bounds.length === 2;
    },
    updatedCluster(clusterId) {
      return true;
    }
  },
  slots: Object,
  setup(props, { emit, slots }) {
    const features = inject("clusterFeatures");
    return () => {
      let clusterSlots;
      if (isVue2()) {
        clusterSlots = features.value.map((feature) => h(_sfc_main$5, {
          props: {
            clusterMarkerProps: props.clusterMarkerProps,
            zoomOnClusterClick: props.zoomOnClusterClick,
            feature
          },
          on: {
            trueBounds: (e) => emit("trueBounds", e),
            updatedBounds: (e) => emit("updatedBounds", e),
            updatedCluster: (e) => emit("updatedCluster", e)
          },
          scopedSlots: {
            default: (options) => {
              var _a;
              return h("div", {}, [(_a = slots.default) == null ? void 0 : _a.call(slots, options)]);
            }
          },
          key: feature.clusterer.clusterId
        }));
      } else {
        clusterSlots = features.value.map((feature) => h(_sfc_main$5, {
          clusterMarkerProps: props.clusterMarkerProps,
          zoomOnClusterClick: props.zoomOnClusterClick,
          feature,
          onTrueBounds: (e) => emit("trueBounds", e),
          onUpdatedBounds: (e) => emit("updatedBounds", e),
          onUpdatedCluster: (e) => emit("updatedCluster", e),
          key: feature.clusterer.clusterId
        }, {
          default: (options) => {
            var _a;
            return (_a = slots.default) == null ? void 0 : _a.call(slots, options);
          }
        }));
      }
      return hF(clusterSlots);
    };
  }
});
const _sfc_main$3 = defineComponent({
  name: "YandexMapClusterer",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    },
    /**
    * @description All custom (non-settings) props are also supported
    */
    clusterMarkerProps: {
      type: Object,
      default: () => ({})
    },
    /**
    * @description Size of the grid division in pixels
    *
    * Used in settings.method via Yandex clusterByGrid method
    *
    * @see https://yandex.ru/dev/jsapi30/doc/ru/ref/packages/clusterer/
    * @see https://yandex.ru/dev/jsapi30/doc/en/ref/packages/clusterer/
    */
    gridSize: {
      type: Number,
      default: 64
    },
    /**
    * @description Zooms to bounds of features of cluster
    */
    zoomOnClusterClick: {
      type: [Boolean, Object],
      default: false
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    // Exact features bounds returned on cluster click
    trueBounds(bounds) {
      return bounds.length === 2;
    },
    // Auto-corrected features bounds returned on cluster click
    updatedBounds(bounds) {
      return bounds.length === 2;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const mapChildren = shallowRef(null);
    const entities = shallowRef([]);
    const clusterFeatures = shallowRef([]);
    const revision = ref(0);
    const filteredFeatures = computed(() => clusterFeatures.value.filter((x) => x.clusterer.features.length > 1));
    provide("clusterFeatures", filteredFeatures);
    let _clusterByGrid;
    const tickTimeout = computed(() => props.settings.tickTimeout);
    const getSettings = () => {
      const settings = { ...props.settings };
      if (!settings.method && _clusterByGrid) settings.method = _clusterByGrid == null ? void 0 : _clusterByGrid({ gridSize: props.gridSize });
      if (tickTimeout.value) settings.tickTimeout = tickTimeout.value;
      const marker = (feature) => {
        const entity = entities.value.find((x) => x._props.id === feature.id);
        if (!entity) {
          throwException({
            text: `No entity with id ${feature.id} (coordinates: ${feature.geometry.coordinates.join(", ")}) were found in YandexMapClusterer.`,
            isInternal: true,
            warn: true
          });
          return new ymaps3.YMapMarker({ coordinates: feature.geometry.coordinates });
        }
        return entity;
      };
      const cluster = (coordinates) => {
        const foundCluster = clusterFeatures.value.find((x) => x.clusterer.lnglat[0] === coordinates[0] && x.clusterer.lnglat[1] === coordinates[1]);
        if (!foundCluster) {
          throwException({
            text: `No element with coordinates of ${coordinates.join(", ")} were found in YandexMapClusterer.`,
            isInternal: true,
            warn: true
          });
          return new ymaps3.YMapMarker({ coordinates });
        }
        return foundCluster.element;
      };
      const features = entities.value.map((entity, i) => {
        if (!entity._props.id) {
          entity.update({
            id: Math.random().toString() + Date.now().toString()
          });
        }
        return {
          type: "Feature",
          id: entity._props.id,
          geometry: {
            type: "Point",
            coordinates: entity._props.coordinates
          },
          properties: "properties" in entity._props ? entity._props.properties : {}
        };
      });
      settings.onRender = (clustersList) => {
        if (clustersList.length <= 1) revision.value++;
        clusterFeatures.value = clustersList.map((clusterer) => {
          var _a;
          clusterer.clusterId = `cluster-${revision.value}-${clusterer.features.map((x) => x.id).join(",")}`;
          return {
            clusterer,
            element: ((_a = clusterFeatures.value.find((x) => x.clusterer.clusterId === clusterer.clusterId)) == null ? void 0 : _a.element) || new ymaps3.YMapCollection({})
          };
        });
        if (props.settings.onRender) return props.settings.onRender(clustersList);
      };
      return {
        ...settings,
        marker,
        features,
        cluster
      };
    };
    const update = async () => {
      var _a, _b;
      clusterFeatures.value = [];
      await nextTick();
      (_a = mapChildren.value) == null ? void 0 : _a.update(getSettings());
      (_b = mapChildren.value) == null ? void 0 : _b._render();
    };
    watch(() => [props.settings, props.gridSize], () => {
      update();
    }, {
      deep: true
    });
    const init = async () => {
      mapChildren.value = await setupMapChildren({
        createFunction: ({
          YMapClusterer: Clusterer,
          clusterByGrid: _clusterByGrid_
        }) => {
          _clusterByGrid = _clusterByGrid_;
          return new Clusterer(getSettings());
        },
        requiredImport: () => ymaps3.import("@yandex/ymaps3-clusterer@0.0.1"),
        isMapRoot: true,
        mapRootRef: entities
      });
      emit("input", mapChildren.value);
      emit("update:modelValue", mapChildren.value);
    };
    watch(entities, async () => {
      await nextTick();
      update();
    });
    onMounted(() => {
      init();
    });
    return () => {
      var _a, _b;
      if (!mapChildren.value) return h("div");
      if (isVue2()) {
        return h("div", [
          ...((_a = slots.default) == null ? void 0 : _a.call(slots, {})) || [],
          h(_sfc_main$4, {
            props: {
              clusterMarkerProps: props.clusterMarkerProps,
              zoomOnClusterClick: props.zoomOnClusterClick
            },
            on: {
              trueBounds: (e) => emit("trueBounds", e),
              updatedBounds: (e) => emit("updatedBounds", e),
              updatedCluster: () => revision.value++
            },
            scopedSlots: {
              default: (options) => {
                var _a2;
                return h("div", {}, [(_a2 = slots.cluster) == null ? void 0 : _a2.call(slots, options)]);
              }
            }
          })
        ]);
      }
      return h("div", [
        ...((_b = slots.default) == null ? void 0 : _b.call(slots, {})) || [],
        h(_sfc_main$4, {
          clusterMarkerProps: props.clusterMarkerProps,
          zoomOnClusterClick: props.zoomOnClusterClick,
          onTrueBounds: (e) => emit("trueBounds", e),
          onUpdatedBounds: (e) => emit("updatedBounds", e),
          onUpdatedCluster: (e) => revision.value++
        }, {
          default: (options) => {
            var _a2;
            return (_a2 = slots.cluster) == null ? void 0 : _a2.call(slots, options);
          }
        })
      ]);
    };
  }
});
const _sfc_main$2 = defineComponent({
  name: "YandexMapCollection",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    const mapChildren = shallowRef(null);
    onMounted(async () => {
      mapChildren.value = await setupMapChildren({
        createFunction: () => new ymaps3.YMapCollection({}),
        isMapRoot: true
      });
      emit("input", mapChildren.value);
      emit("update:modelValue", mapChildren.value);
    });
    return () => {
      if (!mapChildren.value) return h("div");
      return () => {
        var _a;
        return hVue2((_a = slots.default) == null ? void 0 : _a.call(slots, {}));
      };
    };
  }
});
const _sfc_main$1 = defineComponent({
  name: "YandexMapEntity",
  inheritAttrs: false,
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    let mapChildren;
    const element = ref(null);
    onMounted(async () => {
      mapChildren = await setupMapChildren({
        createFunction: () => {
          class Entity extends ymaps3.YMapEntity {
            _onAttach() {
              this._element = element.value;
              this._detachDom = ymaps3.useDomContext(this, this._element);
            }
            _onDetach() {
              this._detachDom();
              this._detachDom = null;
              this._element = null;
            }
          }
          return new Entity({});
        }
      });
      emit("input", mapChildren);
      emit("update:modelValue", mapChildren);
    });
    return () => {
      var _a;
      return hF([
        h("div", {
          ref: element,
          ...getAttrsForVueVersion(attrs)
        }, (_a = slots.default) == null ? void 0 : _a.call(slots, {}))
      ]);
    };
  }
});
const _sfc_main = defineComponent({
  name: "YandexMapRuler",
  props: {
    value: {
      type: Object,
      default: null
    },
    modelValue: {
      type: Object,
      default: null
    },
    settings: {
      type: Object,
      default: () => ({})
    },
    pointProps: {
      type: Object,
      default: () => ({})
    },
    previewPointProps: {
      type: [String, Object],
      default: () => ({})
    },
    /**
    * @description readonly-array with all points states
    */
    pointsState: {
      type: Array,
      default: () => []
    }
  },
  emits: {
    "input"(item) {
      return true;
    },
    "update:modelValue"(item) {
      return true;
    },
    "update:pointsState"(item) {
      return true;
    }
  },
  slots: Object,
  setup(props, {
    slots,
    emit
  }) {
    let mapChildren;
    class RulerPoint extends ymaps3.YMapComplexEntity {
      constructor(props2, entity) {
        super(props2);
        __publicField(this, "entity");
        this.entity = entity;
      }
      _onUpdate(props2) {
        if (props2.state !== void 0) {
          this.entity.state.state = props2.state;
          triggerRef(entities);
        }
      }
    }
    const previewPoint = ref(null);
    const entities = shallowRef([]);
    watch(entities, () => {
      emit("update:pointsState", entities.value.map((x) => x.state));
    });
    const getEntity = (state) => {
      const rulerPoint = {};
      rulerPoint.entity = new RulerPoint(state, rulerPoint);
      return rulerPoint;
    };
    const handleEntityRequest = (params) => {
      const entity = getEntity(params);
      entities.value.splice(params.state.index, 0, entity);
      entity.state = params;
      triggerRef(entities);
      return entity.entity;
    };
    const handleUpdate = (state) => {
      var _a, _b;
      (_b = (_a = props.settings).onUpdate) == null ? void 0 : _b.call(_a, state);
      if (state.points.length >= entities.value.length) return;
      entities.value = entities.value.filter(({ state: x }, index) => String(state.points[index]) === String(x == null ? void 0 : x.state.coordinates));
    };
    const settings = computed(() => {
      return {
        ...props.settings,
        point: handleEntityRequest,
        previewPoint: previewPoint.value ?? document.createElement("div"),
        onUpdate: handleUpdate
      };
    });
    onMounted(async () => {
      try {
        mapChildren = await setupMapChildren({
          createFunction: (controls) => new controls.YMapRuler(settings.value),
          requiredImport: () => ymaps3.import("@yandex/ymaps3-ruler"),
          settings
        });
        emit("input", mapChildren);
        emit("update:modelValue", mapChildren);
      } catch (e) {
        console.error(e);
      }
    });
    const containerProps = computed(() => {
      var _a, _b, _c, _d;
      return getMarkerContainerProps({
        position: ((_a = props.pointProps) == null ? void 0 : _a.position) ?? "top-center left-center",
        containerAttrs: (_b = props.pointProps) == null ? void 0 : _b.containerAttrs,
        wrapperAttrs: (_c = props.pointProps) == null ? void 0 : _c.wrapperAttrs,
        zeroSizes: (_d = props.pointProps) == null ? void 0 : _d.zeroSizes
      });
    });
    const previewProps = computed(() => {
      const settings2 = props.previewPointProps === "fromPointProps" ? props.pointProps : props.previewPointProps;
      return getMarkerContainerProps({
        position: settings2.position ?? "top-center left-center",
        containerAttrs: settings2.containerAttrs,
        wrapperAttrs: settings2.wrapperAttrs,
        zeroSizes: settings2.zeroSizes
      });
    });
    return () => {
      const list = Object.values(entities.value);
      const entitiesSlots = list.map(({ entity, state }) => {
        return hF([
          h("div", {
            ...containerProps.value.root,
            ref: (element) => {
              if (!element) return;
              const settings2 = {
                ...props.pointProps,
                coordinates: state.state.coordinates,
                draggable: props.settings.editable ?? state.state.editable,
                source: state.state.source,
                onDragEnd: (...args) => {
                  var _a, _b;
                  (_b = (_a = props.pointProps).onDragEnd) == null ? void 0 : _b.call(_a, ...args);
                  state.onDragEnd(...args);
                },
                onDragMove: (...args) => {
                  var _a, _b;
                  (_b = (_a = props.pointProps).onDragMove) == null ? void 0 : _b.call(_a, ...args);
                  state.onDragMove(...args);
                },
                onDragStart: (...args) => {
                  var _a, _b;
                  (_b = (_a = props.pointProps).onDragStart) == null ? void 0 : _b.call(_a, ...args);
                  state.onDragStart(...args);
                }
              };
              if (entity.children.length && element.closest("ymaps")) {
                const marker2 = entity.children[0];
                marker2.update(settings2);
                return;
              }
              const marker = new ymaps3.YMapMarker(settings2, element);
              entity.children.map((x) => entity.removeChild(x));
              entity.addChild(marker);
            }
          }, [h("div", containerProps.value.children, slots.point(state))])
        ], {
          key: String(state.state.index) + (state == null ? void 0 : state.state.totalCount)
        });
      });
      return hVue2([
        hF(entitiesSlots),
        h("div", {
          ...previewProps.value.root,
          ref: previewPoint
        }, [h("div", previewProps.value.children, slots.previewPoint({}))])
      ]);
    };
  }
});
export {
  VueYandexMaps,
  _sfc_main$q as YandexMap,
  _sfc_main$9 as YandexMapCartesianProjection,
  _sfc_main$3 as YandexMapClusterer,
  _sfc_main$2 as YandexMapCollection,
  _sfc_main$e as YandexMapControl,
  _sfc_main$d as YandexMapControlButton,
  _sfc_main$f as YandexMapControls,
  _sfc_main$o as YandexMapDefaultFeaturesLayer,
  _sfc_main$h as YandexMapDefaultMarker,
  _sfc_main$m as YandexMapDefaultSatelliteLayer,
  _sfc_main$n as YandexMapDefaultSchemeLayer,
  _sfc_main$1 as YandexMapEntity,
  _sfc_main$g as YandexMapFeature,
  _sfc_main$k as YandexMapFeatureDataSource,
  _sfc_main$c as YandexMapGeolocationControl,
  _sfc_main$7 as YandexMapHint,
  _sfc_main$j as YandexMapLayer,
  _sfc_main$p as YandexMapListener,
  _sfc_main$i as YandexMapMarker,
  _sfc_main$6 as YandexMapOpenMapsButton,
  _sfc_main as YandexMapRuler,
  _sfc_main$a as YandexMapScaleControl,
  _sfc_main$8 as YandexMapSphericalMercatorProjection,
  _sfc_main$l as YandexMapTileDataSource,
  _sfc_main$b as YandexMapZoomControl,
  createYmaps,
  createYmapsOptions,
  createYmapsVue2,
  getBoundsFromCoords,
  getCenterFromCoords,
  getLocationFromBounds,
  initYmaps,
  useYMapsLocationFromBounds
};
